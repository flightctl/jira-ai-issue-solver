package services

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"jira-ai-issue-solver/models"

	"go.uber.org/zap"
)

// GeminiService interface for code generation using Gemini CLI
type GeminiService interface {
	AIService
	// GenerateCodeGemini generates code using Gemini CLI and returns GeminiResponse
	GenerateCodeGemini(prompt string, repoDir string) (*models.GeminiResponse, error)
}

// GeminiServiceImpl implements the GeminiService interface
type GeminiServiceImpl struct {
	config   *models.Config
	executor models.CommandExecutor
	logger   *zap.Logger
}

// NewGeminiService creates a new GeminiService
func NewGeminiService(config *models.Config, logger *zap.Logger, executor ...models.CommandExecutor) GeminiService {
	commandExecutor := exec.Command
	if len(executor) > 0 {
		commandExecutor = executor[0]
	}
	return &GeminiServiceImpl{
		config:   config,
		executor: commandExecutor,
		logger:   logger,
	}
}

// GenerateCode implements the AIService interface
func (s *GeminiServiceImpl) GenerateCode(prompt string, repoDir string) (interface{}, error) {
	return s.GenerateCodeGemini(prompt, repoDir)
}

// GenerateDocumentation implements the AIService interface
func (s *GeminiServiceImpl) GenerateDocumentation(repoDir string) error {
	// Check if GEMINI.md already exists
	geminiPath := filepath.Join(repoDir, "GEMINI.md")
	if _, err := os.Stat(geminiPath); err == nil {
		s.logger.Info("GEMINI.md already exists, skipping generation", zap.String("repo_dir", repoDir))
		return nil
	}

	s.logger.Info("GEMINI.md not found, generating documentation", zap.String("repo_dir", repoDir))

	// Create prompt for generating GEMINI.md
	prompt := `Create a comprehensive GEMINI.md file in the root of the project that serves as an index and guide to all markdown documentation in this repository.

## Requirements:
1. **File Structure**: Create a well-organized document with clear sections and subsections
2. **File Index**: List all markdown files found in the repository (including nested folders) with:
   - Proper headlines for each file
   - Brief descriptions of what each file contains
   - Links to the actual files rather than copying their content
3. **Organization**: Group files logically (e.g., by directory, by purpose)
4. **Navigation**: Include a table of contents at the top
5. **Context**: Provide context about how the files relate to each other
6. **Keep it short and concise**: Keep the file short and concise, don't include any unnecessary details

## Format:
- Use clear, descriptive headlines for each file entry
- Include a brief description (1-2 sentences) explaining what each file covers
- Use relative links to the actual markdown files
- Organize files in a logical structure
- Make it easy for users to find relevant documentation

## Example structure:
# GEMINI.md

## Table of Contents
- [Getting Started](#getting-started)
- [Documentation](#documentation)
- [Contributing](#contributing)

## Getting Started
- [README.md](./README.md) - Main project overview and setup instructions
- [INSTALL.md](./docs/INSTALL.md) - Detailed installation guide

## Documentation
- [API.md](./docs/API.md) - API reference and usage examples
- [ARCHITECTURE.md](./docs/ARCHITECTURE.md) - System architecture overview

## Contributing
- [CONTRIBUTING.md](./CONTRIBUTING.md) - Guidelines for contributors
- [STYLE.md](./docs/STYLE.md) - Code style and formatting guidelines

Search the entire repository for all .md files and create a comprehensive index following this structure.
IMPORTANT: Verify that you actually created and wrote GEMINI.md at the root of the project!`

	// Generate the documentation using Gemini
	response, err := s.GenerateCodeGemini(prompt, repoDir)
	if err != nil {
		return fmt.Errorf("failed to generate GEMINI.md: %w", err)
	}

	// Debug: Print the response to see what we got
	s.logger.Debug("Gemini documentation generation response",
		zap.String("response_type", response.Type),
		zap.Bool("is_error", response.IsError),
		zap.String("result", response.Result))

	if response != nil && response.Message != nil {
		s.logger.Debug("Message content", zap.String("content", response.Message.Content))
	}

	// Extract content from the response and write to file
	var content string
	if response != nil && response.Message != nil {
		content = response.Message.Content
	} else if response != nil && response.Result != "" {
		content = response.Result
	} else {
		content = "# GEMINI.md\n\nThis file was generated by the Gemini AI service.\n"
	}

	s.logger.Debug("Generated GEMINI.md content", zap.String("content", content))

	// Instead of writing to the file, just ensure GEMINI.md exists (create if missing, but don't write content)
	// Check if GEMINI.md exists, but do not create it.
	if _, err := os.Stat(geminiPath); os.IsNotExist(err) {
		return fmt.Errorf("GEMINI.md does not exist at path: %s", geminiPath)
	} else if err != nil {
		return fmt.Errorf("failed to check GEMINI.md: %w", err)
	}

	s.logger.Info("Successfully generated GEMINI.md", zap.String("repo_dir", repoDir))
	return nil
}

// GenerateCodeGemini generates code using Gemini CLI
func (s *GeminiServiceImpl) GenerateCodeGemini(prompt string, repoDir string) (*models.GeminiResponse, error) {
	// Build command arguments based on configuration
	s.logger.Info("Generating code with Gemini", zap.String("repo_dir", repoDir), zap.String("prompt", prompt))

	args := []string{"--debug", "--y"}
	// Add model if configured
	if s.config.Gemini.Model != "" {
		args = append(args, "-m", s.config.Gemini.Model)
	}
	// Add all files flag if configured
	if s.config.Gemini.AllFiles {
		args = append(args, "-a")
	}
	// Add sandbox flag if configured
	if s.config.Gemini.Sandbox {
		args = append(args, "-s")
	}
	// Add prompt
	args = append(args, "-p", prompt)

	// Set up a context with timeout
	timeout := time.Duration(s.config.Gemini.Timeout) * time.Second
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	// Create the command with context
	cmd := exec.CommandContext(ctx, s.config.Gemini.CLIPath, args...)
	cmd.Dir = repoDir

	// Print the actual command being executed
	s.logger.Debug("Executing Gemini CLI",
		zap.String("command", s.config.Gemini.CLIPath),
		zap.Strings("args", args),
		zap.String("directory", repoDir))

	// Set environment variables
	cmd.Env = os.Environ()

	// Set Gemini API key if configured
	if s.config.Gemini.APIKey != "" {
		cmd.Env = append(cmd.Env, fmt.Sprintf("GEMINI_API_KEY=%s", s.config.Gemini.APIKey))
		s.logger.Debug("Gemini API key set", zap.String("api_key", s.config.Gemini.APIKey))
	} else {
		s.logger.Debug("Gemini API key not set")
	}

	// Create pipes for stdout and stderr
	stdoutPipe, err := cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
	}

	stderrPipe, err := cmd.StderrPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create stderr pipe: %w", err)
	}

	// Start the command
	if err := cmd.Start(); err != nil {
		return nil, fmt.Errorf("failed to start Gemini CLI: %w", err)
	}

	var wg sync.WaitGroup
	wg.Add(2) // We have two goroutines for logging (stdout and stderr)

	// Log stdout concurrently
	go func() {
		defer func() {
			s.logger.Debug("Gemini stdout logging goroutine finished")
			wg.Done()
		}()
		scanner := bufio.NewScanner(stdoutPipe)
		// Increase buffer size to handle large output
		buf := make([]byte, 1024*1024) // 1MB buffer
		scanner.Buffer(buf, 1024*1024)
		for scanner.Scan() {
			line := strings.TrimSpace(scanner.Text())
			if line == "" {
				continue
			}

			// Log each line for debugging in real-time
			cleaned := strings.ReplaceAll(line, "Flushing log events to Clearcut.", "")
			cleaned = strings.TrimSpace(cleaned)
			if cleaned != "" {
				s.logger.Debug(cleaned)
			}
		}
	}()

	// Log stderr concurrently
	go func() {
		defer func() {
			s.logger.Debug("Gemini stderr logging goroutine finished")
			wg.Done()
		}()
		scanner := bufio.NewScanner(stderrPipe)
		// Increase buffer size to handle large output
		buf := make([]byte, 1024*1024) // 1MB buffer
		scanner.Buffer(buf, 1024*1024)
		for scanner.Scan() {
			s.logger.Debug("=== Gemini stderr ===\n" + scanner.Text() + "\n===================")
		}
	}()

	// Wait for the command to finish or for the timeout to be reached
	err = cmd.Wait()
	s.logger.Debug("Gemini CLI finished")

	// Wait for the logging goroutines to finish
	// This ensures we capture all output before the function exits
	wg.Wait()
	s.logger.Debug("Gemini CLI logging goroutines finished")

	// Print the command exit code if possible
	exitCode := -1
	if exitErr, ok := err.(*exec.ExitError); ok {
		if status, ok := exitErr.Sys().(interface{ ExitStatus() int }); ok {
			exitCode = status.ExitStatus()
		}
		s.logger.Debug("Gemini CLI exited with code", zap.Int("exit_code", exitCode))
	} else if err == nil {
		// If no error, exit code is 0
		exitCode = 0
		s.logger.Debug("Gemini CLI exited with code", zap.Int("exit_code", exitCode))
	}

	if err != nil {
		// The context being canceled will result in an error
		if ctx.Err() == context.DeadlineExceeded {
			return nil, fmt.Errorf("gemini CLI timed out after %d seconds", s.config.Gemini.Timeout)
		}
		return nil, fmt.Errorf("gemini CLI failed: %w", err)
	}

	// Create response indicating completion
	response := &models.GeminiResponse{
		Type:    "assistant",
		IsError: false,
		Result:  "done",
		Message: &models.GeminiMessage{
			Type:    "message",
			Role:    "assistant",
			Model:   s.config.Gemini.Model,
			Content: "done",
		},
	}

	s.logger.Debug("Capturing final Gemini response...")
	s.logger.Debug("Output processing complete. Final response captured.")
	return response, nil
}

// PreparePrompt prepares a prompt for Gemini CLI based on the Jira ticket
func PreparePromptForGemini(ticket *models.JiraTicketResponse) string {
	var sb strings.Builder

	sb.WriteString("# Task\n\n")
	sb.WriteString(fmt.Sprintf("## %s\n\n", ticket.Fields.Summary))
	sb.WriteString(fmt.Sprintf("%s\n\n", ticket.Fields.Description))

	// Add comments if available
	if len(ticket.Fields.Comment.Comments) > 0 {
		sb.WriteString("## Comments\n\n")
		for _, comment := range ticket.Fields.Comment.Comments {
			sb.WriteString(fmt.Sprintf("**%s** (%s):\n%s\n\n",
				comment.Author.DisplayName,
				comment.Created.Format("2006-01-02 15:04:05"),
				comment.Body))
		}
	}

	sb.WriteString("# Instructions\n\n")
	sb.WriteString("1. First, examine any relevant *.md files (README.md, CONTRIBUTING.md, etc.) in the repository (these might be nested so search the entire repo!) to understand the project structure, testing conventions, and how to run tests.\n")
	sb.WriteString("2. Analyze the task description and comments.\n")
	sb.WriteString("3. Implement the necessary changes to fulfill the requirements.\n")
	sb.WriteString("4. Write tests for the implemented functionality if appropriate.\n")
	sb.WriteString("5. Update documentation if necessary.\n")
	sb.WriteString("6. Make sure the project builds successfully before running tests.\n")
	sb.WriteString("7. Review the markdown files (README.md, CONTRIBUTING.md, etc.) to understand how tests should be run for this project. These files might be nested inside directories, so search the entire repository structure.\n")
	sb.WriteString("8. Verify your changes by running the relevant tests to ensure they work correctly.\n")
	sb.WriteString("9. Provide a summary of the changes made.\n")
	sb.WriteString("10. IMPORTANT: Do NOT perform any git operations (commit, push, pull, etc.). Git handling is managed by the system.\n\n")

	return sb.String()
}

// PreparePromptForPRFeedbackGemini prepares a prompt for Gemini CLI based on PR feedback
func PreparePromptForPRFeedbackGemini(pr *models.GitHubPullRequest, review *models.GitHubReview, repoDir string) (string, error) {
	var sb strings.Builder

	sb.WriteString("# Pull Request Feedback\n\n")
	sb.WriteString(fmt.Sprintf("## PR: %s\n\n", pr.Title))
	sb.WriteString(fmt.Sprintf("%s\n\n", pr.Body))

	sb.WriteString("## Review Feedback\n\n")
	sb.WriteString(fmt.Sprintf("**%s**:\n%s\n\n", review.User.Login, review.Body))

	// Get the diff of the PR
	cmd := exec.Command("git", "diff", "origin/main...HEAD")
	cmd.Dir = repoDir

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("failed to get PR diff: %w, stderr: %s", err, stderr.String())
	}

	sb.WriteString("## Current Changes\n\n")
	sb.WriteString("```diff\n")
	sb.WriteString(stdout.String())
	sb.WriteString("\n```\n\n")

	sb.WriteString("# Instructions\n\n")
	sb.WriteString("1. Analyze the PR feedback and the current changes.\n")
	sb.WriteString("2. Implement the necessary changes to address the feedback.\n")
	sb.WriteString("3. Update tests if necessary.\n")
	sb.WriteString("4. Update documentation if necessary.\n")
	sb.WriteString("5. Make sure the project builds successfully before running tests.\n")
	sb.WriteString("6. Review the markdown files (README.md, CONTRIBUTING.md, etc.) to understand how tests should be run for this project. These files might be nested inside directories, so search the entire repository structure.\n")
	sb.WriteString("7. Verify your changes by running the relevant tests to ensure they work correctly.\n")
	sb.WriteString("8. Provide a summary of the changes made.\n")
	sb.WriteString("9. IMPORTANT: Do NOT perform any git operations (commit, push, pull, etc.). Git handling is managed by the system.\n\n")

	sb.WriteString("# Output Format\n\n")
	sb.WriteString("Please provide your response in the following format:\n\n")
	sb.WriteString("```\n")
	sb.WriteString("## Summary\n")
	sb.WriteString("<A brief summary of the changes made>\n\n")
	sb.WriteString("## Changes Made\n")
	sb.WriteString("<List of files modified and a description of the changes>\n\n")
	sb.WriteString("## Feedback Addressed\n")
	sb.WriteString("<Description of how the feedback was addressed>\n")
	sb.WriteString("```\n")

	return sb.String(), nil
}
