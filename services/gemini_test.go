package services

import (
	"os"
	"path/filepath"
	"testing"

	"go.uber.org/zap"

	"jira-ai-issue-solver/models"
)

func TestGeminiService_GenerateDocumentation(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-doc-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create a test README.md file
	readmeContent := `# Test Project

This is a test project for documentation generation.

## Usage

Run the project with:

` + "```bash" + `
go run main.go
` + "```" + `

## Contributing

Please read CONTRIBUTING.md for details.
`
	readmePath := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		t.Fatalf("Failed to create README.md: %v", err)
	}

	// Test that GEMINI.md doesn't exist initially
	geminiPath := filepath.Join(tempDir, "GEMINI.md")
	if _, err := os.Stat(geminiPath); err == nil {
		t.Fatal("GEMINI.md should not exist initially")
	}

	// Create a simple mock service for testing
	mockService := &mockGeminiServiceForTest{}

	// Generate documentation
	err = mockService.GenerateDocumentation(tempDir)
	if err != nil {
		t.Fatalf("GenerateDocumentation failed: %v", err)
	}

	// Test that GEMINI.md exists after generation
	if _, err := os.Stat(geminiPath); err != nil {
		t.Fatal("GEMINI.md should exist after generation")
	}

	// Test that calling GenerateDocumentation again doesn't fail (should skip)
	err = mockService.GenerateDocumentation(tempDir)
	if err != nil {
		t.Fatalf("Second call to GenerateDocumentation failed: %v", err)
	}
}

func TestGeminiService_GenerateDocumentation_RealCLI(t *testing.T) {
	// Create test logger
	logger := zap.NewNop()

	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-doc-test-real")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create a test README.md file
	readmeContent := `# Test Project

This is a test project for documentation generation.

## Usage

Run the project with:

` + "```bash" + `
go run main.go
` + "```" + `

## Contributing

Please read CONTRIBUTING.md for details.
`
	readmePath := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		t.Fatalf("Failed to create README.md: %v", err)
	}

	// Create a test config with echo as CLI to see the output
	config := &models.Config{}
	config.Gemini.CLIPath = "echo"
	config.Gemini.Timeout = 60
	config.Gemini.Model = "gemini-2.5-pro"

	// Create a Gemini service
	service := NewGeminiService(config, logger)

	// Test that GEMINI.md doesn't exist initially
	geminiPath := filepath.Join(tempDir, "GEMINI.md")
	if _, err := os.Stat(geminiPath); err == nil {
		t.Fatal("GEMINI.md should not exist initially")
	}

	// Generate documentation - this should print the CLI output
	err = service.GenerateDocumentation(tempDir)
	if err != nil {
		t.Logf("GenerateDocumentation failed (expected with echo): %v", err)
		// This is expected to fail with echo, but we want to see the output
		return
	}

	// If it succeeds, check that GEMINI.md exists
	if _, err := os.Stat(geminiPath); err != nil {
		t.Fatal("GEMINI.md should exist after generation")
	}
}

// mockGeminiServiceForTest is a simple mock for testing
type mockGeminiServiceForTest struct{}

func (m *mockGeminiServiceForTest) GenerateDocumentation(repoDir string) error {
	// Check if GEMINI.md already exists
	geminiPath := filepath.Join(repoDir, "GEMINI.md")
	if _, err := os.Stat(geminiPath); err == nil {
		return nil // Already exists
	}

	// Create a mock GEMINI.md file
	content := `# GEMINI.md

This file was automatically generated by the Gemini AI service.

## Table of Contents
- [Getting Started](#getting-started)
- [Documentation](#documentation)

## Getting Started
- [README.md](./README.md) - Main project overview and setup instructions

## Documentation
- [Test Project](./README.md#test-project) - Overview of the test project
`
	return os.WriteFile(geminiPath, []byte(content), 0644)
}
