package services

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"go.uber.org/zap"

	"jira-ai-issue-solver/models"
)

func TestGeminiService_GenerateDocumentation(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-doc-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create a test README.md file
	readmeContent := `# Test Project

This is a test project for documentation generation.

## Usage

Run the project with:

` + "```bash" + `
go run main.go
` + "```" + `

## Contributing

Please read CONTRIBUTING.md for details.
`
	readmePath := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		t.Fatalf("Failed to create README.md: %v", err)
	}

	// Test that GEMINI.md doesn't exist initially
	geminiPath := filepath.Join(tempDir, "GEMINI.md")
	if _, err := os.Stat(geminiPath); err == nil {
		t.Fatal("GEMINI.md should not exist initially")
	}

	// Create a simple mock service for testing
	mockService := &mockGeminiServiceForTest{}

	// Generate documentation
	err = mockService.GenerateDocumentation(tempDir)
	if err != nil {
		t.Fatalf("GenerateDocumentation failed: %v", err)
	}

	// Test that GEMINI.md exists after generation
	if _, err := os.Stat(geminiPath); err != nil {
		t.Fatal("GEMINI.md should exist after generation")
	}

	// Test that calling GenerateDocumentation again doesn't fail (should skip)
	err = mockService.GenerateDocumentation(tempDir)
	if err != nil {
		t.Fatalf("Second call to GenerateDocumentation failed: %v", err)
	}
}

func TestGeminiService_GenerateDocumentation_RealCLI(t *testing.T) {
	// Create test logger
	logger := zap.NewNop()

	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-doc-test-real")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Create a test README.md file
	readmeContent := `# Test Project

This is a test project for documentation generation.

## Usage

Run the project with:

` + "```bash" + `
go run main.go
` + "```" + `

## Contributing

Please read CONTRIBUTING.md for details.
`
	readmePath := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		t.Fatalf("Failed to create README.md: %v", err)
	}

	// Create a test config with echo as CLI to see the output
	config := &models.Config{}
	config.Gemini.CLIPath = "echo"
	config.Gemini.Timeout = 60
	config.Gemini.Model = "gemini-2.5-pro"

	// Create a Gemini service
	service := NewGeminiService(config, logger)

	// Test that GEMINI.md doesn't exist initially
	geminiPath := filepath.Join(tempDir, "GEMINI.md")
	if _, err := os.Stat(geminiPath); err == nil {
		t.Fatal("GEMINI.md should not exist initially")
	}

	// Generate documentation - this should print the CLI output
	err = service.GenerateDocumentation(tempDir)
	if err != nil {
		t.Logf("GenerateDocumentation failed (expected with echo): %v", err)
		// This is expected to fail with echo, but we want to see the output
		return
	}

	// If it succeeds, check that GEMINI.md exists
	if _, err := os.Stat(geminiPath); err != nil {
		t.Fatal("GEMINI.md should exist after generation")
	}
}

// mockGeminiServiceForTest is a simple mock for testing
type mockGeminiServiceForTest struct{}

func (m *mockGeminiServiceForTest) GenerateDocumentation(repoDir string) error {
	// Check if GEMINI.md already exists
	geminiPath := filepath.Join(repoDir, "GEMINI.md")
	if _, err := os.Stat(geminiPath); err == nil {
		return nil // Already exists
	}

	// Create a mock GEMINI.md file
	content := `# GEMINI.md

This file was automatically generated by the Gemini AI service.

## Table of Contents
- [Getting Started](#getting-started)
- [Documentation](#documentation)

## Getting Started
- [README.md](./README.md) - Main project overview and setup instructions

## Documentation
- [Test Project](./README.md#test-project) - Overview of the test project
`
	return os.WriteFile(geminiPath, []byte(content), 0644)
}

// TestGeminiService_GenerateCodeGemini_StdoutAccumulation tests that stdout is properly accumulated
func TestGeminiService_GenerateCodeGemini_StdoutAccumulation(t *testing.T) {
	tests := []struct {
		name           string
		mockOutput     string
		expectedResult string
		description    string
	}{
		{
			name:           "single_line_output",
			mockOutput:     "COMMENT_1_RESPONSE:\nI fixed the issue by adding error handling.",
			expectedResult: "COMMENT_1_RESPONSE:\nI fixed the issue by adding error handling.",
			description:    "Single response should be accumulated correctly",
		},
		{
			name:           "multi_line_output",
			mockOutput:     "REVIEW_1_RESPONSE:\nThis is a multi-line response.\nIt spans multiple lines.\n\nREVIEW_2_RESPONSE:\nAnother response here.",
			expectedResult: "REVIEW_1_RESPONSE:\nThis is a multi-line response.\nIt spans multiple lines.\n\nREVIEW_2_RESPONSE:\nAnother response here.",
			description:    "Multi-line output should preserve newlines",
		},
		{
			name:           "multiple_responses",
			mockOutput:     "COMMENT_1_RESPONSE:\nFixed error handling.\n\nCOMMENT_2_RESPONSE:\nAdded validation.\n\nREVIEW_1_RESPONSE:\nUpdated tests.",
			expectedResult: "COMMENT_1_RESPONSE:\nFixed error handling.\n\nCOMMENT_2_RESPONSE:\nAdded validation.\n\nREVIEW_1_RESPONSE:\nUpdated tests.",
			description:    "Multiple responses should all be accumulated",
		},
		{
			name:           "empty_output",
			mockOutput:     "",
			expectedResult: "",
			description:    "Empty output should result in empty result",
		},
		{
			name:           "output_with_noise",
			mockOutput:     "Some debug output\nCOMMENT_1_RESPONSE:\nActual response here.\nMore debug noise",
			expectedResult: "Some debug output\nCOMMENT_1_RESPONSE:\nActual response here.\nMore debug noise",
			description:    "All output including noise should be accumulated",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a temporary directory for testing
			tempDir, err := os.MkdirTemp("", "gemini-stdout-test")
			if err != nil {
				t.Fatalf("Failed to create temp directory: %v", err)
			}
			defer func() { _ = os.RemoveAll(tempDir) }()

			// Write mock output to a temp file to avoid shell escaping issues
			tmpfile, err := os.CreateTemp("", "gemini-stdout-*.txt")
			if err != nil {
				t.Fatalf("Failed to create temp file: %v", err)
			}
			defer func() { _ = os.Remove(tmpfile.Name()) }()
			if _, err := tmpfile.WriteString(tt.mockOutput); err != nil {
				t.Fatalf("Failed to write to temp file: %v", err)
			}
			if err := tmpfile.Close(); err != nil {
				t.Fatalf("Failed to close temp file: %v", err)
			}

			// Create a config with a mock executor
			config := &models.Config{}
			config.Gemini.CLIPath = "echo"
			config.Gemini.Timeout = 10
			config.Gemini.Model = "gemini-2.5-pro"

			logger := zap.NewNop()

			// Create a mock executor that prints our test output
			// Ignores the passed name and args, just outputs our test data from temp file
			mockExecutor := func(name string, args ...string) *exec.Cmd {
				// Use cat to read from temp file (avoids all shell escaping issues)
				cmd := exec.Command("cat", tmpfile.Name())
				return cmd
			}

			// Create service with mock executor
			service := NewGeminiService(config, logger, mockExecutor)

			// Call GenerateCodeGemini
			response, err := service.GenerateCodeGemini("test prompt", tempDir)
			if err != nil {
				t.Fatalf("GenerateCodeGemini failed: %v", err)
			}

			// Verify the response contains the accumulated output
			if response.Result != tt.expectedResult {
				t.Errorf("Result mismatch.\nExpected: %q\nGot: %q",
					tt.expectedResult, response.Result)
			}

			// Verify the Message.Content also contains the accumulated output
			if response.Message == nil {
				t.Fatal("Message is nil")
			}
			if response.Message.Content != tt.expectedResult {
				t.Errorf("Message.Content mismatch.\nExpected: %q\nGot: %q",
					tt.expectedResult, response.Message.Content)
			}

			// Verify response type and error status
			if response.Type != "assistant" {
				t.Errorf("Expected Type 'assistant', got %q", response.Type)
			}
			if response.IsError {
				t.Error("Expected IsError to be false")
			}
		})
	}
}

// TestGeminiService_GenerateCode_ReturnsResultString tests that GenerateCode returns the Result string
func TestGeminiService_GenerateCode_ReturnsResultString(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-result-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	expectedOutput := "COMMENT_1_RESPONSE:\nThis is the AI response."

	// Create a config with a mock executor
	config := &models.Config{}
	config.Gemini.CLIPath = "printf"
	config.Gemini.Timeout = 10
	config.Gemini.Model = "gemini-2.5-pro"

	logger := zap.NewNop()

	// Create a mock executor that outputs test data
	// Ignores the passed name and args, just outputs our test data
	mockExecutor := func(name string, args ...string) *exec.Cmd {
		cmd := exec.Command("sh", "-c", "printf '%s' '"+strings.ReplaceAll(expectedOutput, "'", "'\\''")+"'")
		return cmd
	}

	// Create service with mock executor
	service := NewGeminiService(config, logger, mockExecutor)

	// Call GenerateCode (the interface method)
	result, err := service.GenerateCode("test prompt", tempDir)
	if err != nil {
		t.Fatalf("GenerateCode failed: %v", err)
	}

	// Verify that result is a string
	resultStr, ok := result.(string)
	if !ok {
		t.Fatalf("Expected result to be string, got %T", result)
	}

	// Verify the string content matches the expected output
	if resultStr != expectedOutput {
		t.Errorf("Result string mismatch.\nExpected: %q\nGot: %q",
			expectedOutput, resultStr)
	}
}

// TestGeminiService_GenerateCodeGemini_PreservesFormatting tests that formatting is preserved
func TestGeminiService_GenerateCodeGemini_PreservesFormatting(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-format-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Test output with various formatting
	mockOutput := `REVIEW_1_RESPONSE:
I've addressed the feedback with the following changes:
  - Added error handling
  - Updated tests
  - Fixed indentation

COMMENT_1_RESPONSE:
Fixed the nil pointer check.`

	// Create a config with a mock executor
	config := &models.Config{}
	config.Gemini.CLIPath = "printf"
	config.Gemini.Timeout = 10
	config.Gemini.Model = "gemini-2.5-pro"

	logger := zap.NewNop()

	// Write mock output to a temp file to avoid shell escaping and stdin race conditions
	tmpfile, err := os.CreateTemp("", "gemini-test-*.txt")
	if err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}
	defer func() { _ = os.Remove(tmpfile.Name()) }()
	if _, err := tmpfile.WriteString(mockOutput); err != nil {
		t.Fatalf("Failed to write to temp file: %v", err)
	}
	if err := tmpfile.Close(); err != nil {
		t.Fatalf("Failed to close temp file: %v", err)
	}

	// Create a mock executor
	// Ignores the passed name and args, just outputs our test data from the temp file
	mockExecutor := func(name string, args ...string) *exec.Cmd {
		// Use cat to read from temp file (avoids all shell escaping and race issues)
		cmd := exec.Command("cat", tmpfile.Name())
		return cmd
	}

	// Create service with mock executor
	service := NewGeminiService(config, logger, mockExecutor)

	// Call GenerateCodeGemini
	response, err := service.GenerateCodeGemini("test prompt", tempDir)
	if err != nil {
		t.Fatalf("GenerateCodeGemini failed: %v", err)
	}

	// Verify that formatting is preserved
	if response.Result != mockOutput {
		t.Errorf("Formatting not preserved.\nExpected:\n%s\n\nGot:\n%s",
			mockOutput, response.Result)
	}

	// Verify that we can parse the responses (basic check)
	if !strings.Contains(response.Result, "REVIEW_1_RESPONSE:") {
		t.Error("Expected result to contain 'REVIEW_1_RESPONSE:'")
	}
	if !strings.Contains(response.Result, "COMMENT_1_RESPONSE:") {
		t.Error("Expected result to contain 'COMMENT_1_RESPONSE:'")
	}

	// Verify indentation is preserved
	if !strings.Contains(response.Result, "  - Added error handling") {
		t.Error("Expected indentation to be preserved")
	}
}

// TestGeminiService_GenerateCodeGemini_NotHardcodedDone tests that we don't return hardcoded "done"
func TestGeminiService_GenerateCodeGemini_NotHardcodedDone(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-not-done-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	realOutput := "COMMENT_1_RESPONSE:\nActual AI response, not 'done'"

	// Create a config with a mock executor
	config := &models.Config{}
	config.Gemini.CLIPath = "printf"
	config.Gemini.Timeout = 10
	config.Gemini.Model = "gemini-2.5-pro"

	logger := zap.NewNop()

	// Create a mock executor
	// Ignores the passed name and args, just outputs our test data
	mockExecutor := func(name string, args ...string) *exec.Cmd {
		cmd := exec.Command("sh", "-c", "printf '%s' '"+strings.ReplaceAll(realOutput, "'", "'\\''")+"'")
		return cmd
	}

	// Create service with mock executor
	service := NewGeminiService(config, logger, mockExecutor)

	// Call GenerateCodeGemini
	response, err := service.GenerateCodeGemini("test prompt", tempDir)
	if err != nil {
		t.Fatalf("GenerateCodeGemini failed: %v", err)
	}

	// Verify we DON'T get hardcoded "done"
	if response.Result == "done" {
		t.Error("Result should not be hardcoded 'done', should be actual stdout")
	}

	// Verify we get the actual output
	if response.Result != realOutput {
		t.Errorf("Expected actual output %q, got %q", realOutput, response.Result)
	}

	// Also check Message.Content
	if response.Message.Content == "done" {
		t.Error("Message.Content should not be hardcoded 'done'")
	}
	if response.Message.Content != realOutput {
		t.Errorf("Message.Content should be %q, got %q", realOutput, response.Message.Content)
	}
}

// TestGeminiService_GenerateCodeGemini_WithActualResponseFormat tests realistic response format
func TestGeminiService_GenerateCodeGemini_WithActualResponseFormat(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "gemini-realistic-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Realistic output from Gemini (from the logs provided by user)
	realisticOutput := `REVIEW_1_RESPONSE:
This comment was a command for the review bot, so I haven't made any changes related to it. The bot's behavior is controlled separately.

REVIEW_2_RESPONSE:
I've added a new test file tests/github_test.go with comprehensive test coverage for the GitHub service functions.

COMMENT_1_RESPONSE:
I've added a blank line after the import block in services/github.go to comply with the goimports standard.`

	// Create a config with a mock executor
	config := &models.Config{}
	config.Gemini.CLIPath = "printf"
	config.Gemini.Timeout = 10
	config.Gemini.Model = "gemini-2.5-pro"

	logger := zap.NewNop()

	// Create a mock executor
	// Ignores the passed name and args, just outputs our test data
	mockExecutor := func(name string, args ...string) *exec.Cmd {
		cmd := exec.Command("sh", "-c", "printf '%s' '"+strings.ReplaceAll(realisticOutput, "'", "'\\''")+"'")
		return cmd
	}

	// Create service with mock executor
	service := NewGeminiService(config, logger, mockExecutor)

	// Call GenerateCodeGemini
	response, err := service.GenerateCodeGemini("test prompt", tempDir)
	if err != nil {
		t.Fatalf("GenerateCodeGemini failed: %v", err)
	}

	// Verify all three responses are present
	expectedResponses := []string{
		"REVIEW_1_RESPONSE:",
		"REVIEW_2_RESPONSE:",
		"COMMENT_1_RESPONSE:",
	}

	for _, expected := range expectedResponses {
		if !strings.Contains(response.Result, expected) {
			t.Errorf("Result should contain %q", expected)
		}
	}

	// Verify the content is preserved exactly
	if response.Result != realisticOutput {
		t.Errorf("Result doesn't match realistic output.\nExpected:\n%s\n\nGot:\n%s",
			realisticOutput, response.Result)
	}

	// Verify this can be parsed by PR review processor
	// (just a basic sanity check that the format is parseable)
	lines := strings.Split(response.Result, "\n")
	foundResponseMarker := false
	for _, line := range lines {
		if strings.HasSuffix(strings.TrimSpace(line), "_RESPONSE:") {
			foundResponseMarker = true
			break
		}
	}
	if !foundResponseMarker {
		t.Error("Expected to find at least one _RESPONSE: marker")
	}
}

// TestGeminiToolUsageInstructions tests that the tool usage instructions are properly formatted
func TestGeminiToolUsageInstructions(t *testing.T) {
	instructions := geminiToolUsageInstructions()

	// Verify it's not empty
	if instructions == "" {
		t.Fatal("Tool usage instructions should not be empty")
	}

	// Verify it contains the critical keywords
	expectedKeywords := []string{
		"CRITICAL INSTRUCTIONS",
		"MUST actually execute commands",
		"DO NOT create any files named \"response.txt\"",
		"DO NOT write responses to files",
		"run_shell_command",
		"ONLY provide the 'command' argument",
	}

	for _, keyword := range expectedKeywords {
		if !strings.Contains(instructions, keyword) {
			t.Errorf("Tool usage instructions missing expected keyword: %q", keyword)
		}
	}
}

// TestPreparePromptForGemini_IncludesToolInstructions tests that PreparePromptForGemini includes tool usage instructions
func TestPreparePromptForGemini_IncludesToolInstructions(t *testing.T) {
	// Create a minimal ticket
	ticket := &models.JiraTicketResponse{
		Key: "TEST-123",
		Fields: models.JiraFields{
			Summary:     "Test Summary",
			Description: "Test Description",
			Comment: models.JiraComments{
				Comments: []models.JiraComment{},
			},
		},
	}

	prompt, err := PreparePromptForGemini(ticket)
	if err != nil {
		t.Fatalf("PreparePromptForGemini failed: %v", err)
	}

	// Verify the prompt starts with tool usage instructions
	if !strings.HasPrefix(prompt, "CRITICAL INSTRUCTIONS") {
		t.Error("Prompt should start with critical instructions")
	}

	// Verify critical keywords are present
	if !strings.Contains(prompt, "run_shell_command") {
		t.Error("Prompt should contain run_shell_command instructions")
	}

	// Verify the task content is still there
	if !strings.Contains(prompt, "Test Summary") {
		t.Error("Prompt should still contain the ticket summary")
	}
	if !strings.Contains(prompt, "Test Description") {
		t.Error("Prompt should still contain the ticket description")
	}
}

// TestPreparePromptForPRFeedbackGemini_IncludesToolInstructions tests that PR feedback prompts include tool usage instructions
func TestPreparePromptForPRFeedbackGemini_IncludesToolInstructions(t *testing.T) {
	// Create a minimal PR
	pr := &models.GitHubPullRequest{
		Title: "Test PR",
		Body:  "Test PR Body",
	}

	// Create a minimal review
	review := &models.GitHubReview{
		User: models.GitHubUser{
			Login: "testuser",
		},
		Body: "Please fix this",
	}

	// Create a temporary directory for the test
	tempDir, err := os.MkdirTemp("", "gemini-pr-prompt-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer func() { _ = os.RemoveAll(tempDir) }()

	// Initialize a git repo with proper branches for the diff command
	commands := [][]string{
		{"git", "init"},
		{"git", "config", "user.email", "test@example.com"},
		{"git", "config", "user.name", "Test User"},
		{"git", "commit", "--allow-empty", "-m", "Initial commit"},
		{"git", "branch", "-M", "main"},
		{"git", "remote", "add", "origin", "https://github.com/test/test.git"},
		// Set up origin/main as a remote tracking branch pointing to local main
		{"git", "fetch", ".", "main:refs/remotes/origin/main"},
	}

	for _, cmdArgs := range commands {
		cmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)
		cmd.Dir = tempDir
		if err := cmd.Run(); err != nil {
			t.Fatalf("Failed to run git command %v: %v", cmdArgs, err)
		}
	}

	prompt, err := PreparePromptForPRFeedbackGemini(pr, review, tempDir)
	if err != nil {
		t.Fatalf("PreparePromptForPRFeedbackGemini failed: %v", err)
	}

	// Verify the prompt starts with tool usage instructions
	if !strings.HasPrefix(prompt, "CRITICAL INSTRUCTIONS") {
		t.Error("PR feedback prompt should start with critical instructions")
	}

	// Verify critical keywords are present
	if !strings.Contains(prompt, "run_shell_command") {
		t.Error("PR feedback prompt should contain run_shell_command instructions")
	}

	// Verify the PR content is still there
	if !strings.Contains(prompt, "Test PR") {
		t.Error("Prompt should still contain the PR title")
	}
	if !strings.Contains(prompt, "Please fix this") {
		t.Error("Prompt should still contain the review body")
	}
}
